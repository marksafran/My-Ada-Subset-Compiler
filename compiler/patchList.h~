/***********************************************************************
//                          patchList.h
//Name: Mark Safran
//Date: November 13, 2014
//Class: Compiler Construction
//Instrcutor: Professor King
//Purpose:  New structures and functions for Part 4 of the main project.
//           Helps with Loops, Arrays, If/Else Stmts, and I/O operations
//********************************************************************/

struct patchList{
	int instructionNum;
	int fillNum;
	struct patchList* next;
};

typedef struct patchList patchList;

struct toPatch{
	int instructionNum;
	struct toPatch* next;
};
typedef struct toPatch toPatch;

struct stack{
	toPatch *list;
};
struct stack patchStack[100];
int patchStackCount = 0;

struct patchList *thePatchList;

//puts individual instructions and their patched jump addresses
// into the entire patch list, in order
void addInOrder(int instruction, int jumpAddress)
{
	patchList *nextPatch = NULL;
	nextPatch = malloc(sizeof(struct patchList));
	nextPatch = thePatchList;
	patchList *prevPatch = thePatchList;
	prevPatch = malloc(sizeof(struct patchList));
	prevPatch = thePatchList;
	
	patchList *newItem = NULL;
	newItem = malloc(sizeof(struct toPatch));
	newItem->instructionNum = instruction;
	newItem->fillNum = jumpAddress;
	newItem->next = NULL;

	if(thePatchList == NULL){
		printf("patch list is NULL\n");
		thePatchList = malloc(sizeof(struct patchList));
		thePatchList->instructionNum = instruction;
		thePatchList->fillNum = jumpAddress;
		thePatchList->next = NULL;
		printf("gets here\n");
				
	}else{
		if(thePatchList->instructionNum > instruction){
			printf("gets here\n");
			nextPatch = thePatchList;
			thePatchList->instructionNum = instruction;
			thePatchList->fillNum = jumpAddress;
			thePatchList->next = nextPatch;
		}else{
			printf("gets here2\n");
			while(nextPatch != NULL){
				printf("next patch instruct num = %d\n", nextPatch->instructionNum);
				printf("instruct num = %d\n", instruction);
				printf("gets inside while here\n");

				if(nextPatch->instructionNum < instruction){
					
					prevPatch = nextPatch;
					nextPatch = nextPatch->next;
					printf("INSIDE CONDITIONAL!!!\n");
				}
				
			}
			printf("gets here3\n");
			prevPatch->next = newItem;
			newItem->next = nextPatch;
			//prevPatch->next->instructionNum = instruction;
			//printf("prev patch instruct num = %d\n", nextPatch->next->instructionNum);
			//prevPatch->next->fillNum = jumpAddress;
			//prevPatch->next->next = nextPatch;
		}
	}
	
}//end addInOrder

//helper function that runs through an entire toPatch list
// and adds it to the greater PatchList with a call to AddInOrder
void addPatchList(toPatch *toPL, int jumpAddress)
{
	toPatch *tempList = NULL;
	tempList = malloc(sizeof(struct toPatch));
	tempList = toPL;
	
	
	//for all items in the toPatch list
	while(tempList != NULL){

		addInOrder(tempList->instructionNum, jumpAddress);
		tempList = tempList->next;

	}
}//end addPatchList


//adds another level to the stack of toPatch lists
pushPatch()
{
	patchStackCount++;
   
}//end pushPatch

//adds all the elements in the top of the toPatch stack to the
// PatchList with a call to addPatchList, before removing
popPatch(int jumpAddress)
{
	if(patchStackCount <= 0){
		return;
	}else{
		addPatchList(patchStack[patchStackCount].list, jumpAddress);
		stackCount--;
	}

}//end popPatch

//adds an instruction element to the toPatch list on the top
// of the toPatch stack
insertToPatch(int newPatchNum)
{
	toPatch *counter = patchStack[patchStackCount].list;
	toPatch *prev;
	int exists;

	exists = searchToPatch(newPatchNum);
	if(exists != 0){
		printf("already added this instruction\n");
		return;
	}else{
		toPatch *tempPatch = NULL;
		tempPatch = malloc(sizeof(struct toPatch));
		tempPatch->instructionNum = newPatchNum;
	
		if(patchStack[patchStackCount].list == NULL){
			tempPatch->next = NULL;
			patchStack[patchStackCount].list = tempPatch;
		}else{
			while(counter->next != NULL){
				counter = counter->next;
			}
			counter->next = tempPatch;
			tempPatch->next = NULL;
		}

	}

}//end insertToPatch

//searches a single level of the toPatch stack for an
// instruction element
int searchPL(toPatch *thePL, int searchPatchNum)
{
	if(thePL == NULL){
		return 0;
	}else if(thePL->instructionNum == searchPatchNum){
		return 1;
	}else{
		searchPL(thePL->next, searchPatchNum);
	}

}//end searchPL

//helper function to search all levels of the stack.
// calls searchPL
int searchToPatch(int searchPatchNum)
{
	int didSearch;
	int found = 0;
	int i;

	for(i = patchStackCount; i >=0; i--){
		didSearch = searchPL(patchStack[i].list, searchPatchNum);
	
		if(didSearch != 0){
			found = i;
			break;
		}
	}
	return found;
}//end searchToPatch





